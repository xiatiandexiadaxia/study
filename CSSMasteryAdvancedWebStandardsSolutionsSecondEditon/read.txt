第一章 基础知识
有意义的标记
	如果元素有恰当的含义,就应该使用,不应到只使用div等几个元素
id和class
	id用于标识页面上的唯一特定元素
	class用于标识页面同一类元素
	分配id和class,尽量保持名称和表现方式无关,应该根据'他们是什么'来为元素命名,而不应该根据'他们的外观如何来'命名,区分大小写,可以用完全小写,多个单词之间用连字符分割 eg:andy-budd
id还是clss
	class用于概念上相似的元素,这些元素可以出现在同一页面上的多个位置
	id用于不同的唯一的元素
	只有在绝对确定这个元素只会出现一次的情况下,才使用id,如果认为以后可能需要相似的元素,就使用class,避免一长串id选择器相关联的现象 eg:#andy, #rich, #jeremy, $james-box, $paul, $sophie {color:black}
	如果你发现类名中出现了重复的单词,比如news-link和news-head,就应该考虑是否可以把这些元素分解成它们的组成部分.这会让代码更"组件化",会大大提高灵活性,删除不必要的代码
	对类名的过度依赖是完全不必要的,如果发现自己添加了许多类,那意味着HTML文档结构有问题
div和span
	div可以用来对块级元素分组,而span可以用来对行内元素进行分组
	div代表部分,它可以将文档分割为几个有意义的区域,所以通过将主要内容区域包围在div中并分配content类,就可以在文档中添加结构和意义
	应该只在没有现有元素能够实现区域分割的情况下使用div
	eg:主导航列表,就不需要将它包围在div中
		没必要								可以替代
		div class=nav						ul class=nav
			ul									li home /li
				li home /li 				/ul
			/ul
		/div
	过度使用div是代码结构不合理而且过分复杂的信号,div应该根据条目的意义或功能分对相关条目分组,而不是根据他们的表现方式或布局
文档类型
	DTD(文档类型定义),DOCTYPE声明,描述使用哪个DTE,由此知道要使用哪个HTML版本

第二章 为样式找到应用目标
常用的选择器
	常用的选择器是类型选择器和后代选择器
	类型选择器也可以称为元素选择器或者简单选择器 eg: p {...}
	后代选择器可以用来寻找特定元素或元素组的后代,后代选择器由其他两个选择器之间的空格标识 eg:blockquote p {...}
	这两种选择器适合应用范围广的一般样式,想寻找更特定的元素,可以使用id选择器和class选择器 eg:#id {...} .class{...}
	这四种选择器就可以成功的找到许多元素,如果发现文档中添加了许多不必要的类,这是文档结构不合理的信号,应该分析元素之间的差异,将一个class或id应用于它们的祖先,然后使用后代选择器定位它们
伪类
	有时需要根据文档结构之外的其他条件对元素应用样式,例如表单元素或链接的状态,这时使用伪类 eg:a:link {...} a:visited {...}
	:link和:visited称为链接伪类,只能应用于锚元素
	:hover,:active,:focus称为动态伪类,理论上可以应用于任何元素
	:link 未访问的链接
	:visited 已访问的链接
	:hover 鼠标悬停
	:active 被选择
	:focus 获得焦点
	通过把伪类连接在一起,可以创造更复杂的行为 eg:a:visited:hover {...}已访问链接鼠标悬停效果
通用选择器
	通配符,匹配所有可用元素 eg:* {...}
	各种浏览器的内外边距不一样,通常的做法可以在所有css之前清理掉内外边距 eg:* {padding:0;margin:0;}
高级选择器
子选择器和相邻同胞选择器
	子选择器只选择元素的直接后代,就是子元素,和后代选择器不同,后代选择器选择一个元素的所有后代 eg:#nav>li {...}
	子选择器指定列表的子元素样式,但是不影响他的孙元素
	相邻同胞选择器可以定位同一个父元素下某个元素之后的元素 eg:h2+p {...}
	在IE7中如果目标元素,两个元素中有HTML注释,子选择器和相邻同胞选择器会有问题,不过目前已经不考虑兼容IE8以下版本IE浏览器了
属性选择器
	属性选择器可以根据某个属性是否存在或者属性的值来寻找元素 eg:a[rel="name"] {...}
层叠
	层叠给每个规则分配一个重要度,采用以下重要度次序
	1.标有!important的用户样式
	2.标有!important的作者样式
	3.作者样式
	4.用户样式
	5.浏览器/用户代理应用的样式
	作者样式是站点开发者编写的
	用户样式是用户通过浏览器应用自己的样式
	浏览器使用默认样式
	如果两个规则的重要度相同,后定义的规则优先
特殊性
	为了计算规则的特殊性,给每种选择器都分配一个数字值.然后,将规则的买个选择器的值加在一起,计算出规则的特殊性.
	特殊性的计算不是以10为基数的,而是采用一个更高的未指定的技术.确保非常特殊的选择器比如id选择器不会被大量一般选择器比如类型选择器所超越
	为了简化,如果在一个特定选择器中的选择器数量少于10个,那么可以以10为基数计算特殊性
	选择器的特殊性分别分成4个成分等级,a,b,c,d
	1.如果样式是行内样式,那么a=1
	2.b等于id选择器的总数
	3.c等于类,伪类,和属性选择器的数量
	4.d等于类型选择器和伪元素选择器的数量
	总结一下,基本上,用style属性编写的规则总比其他任何规则特殊,有id选择器的规则比没有id选择器的规则特殊,有class选择器的规则比只有类型选择器的规则特殊,如果两个规则的特殊性相同,后定义的规则优先
	修复bug时特殊性极其重要 eg:chapter02>test.html 两个标题都是灰色的.第一个选择器由两个id选择器组成,因此它具有最高的特殊性,后面的选择器更复杂,但是它们只包含一个id所以特殊性总是低于第一个选择器
	如果遇到了似乎没有起作用的CSS规则,很可能是出现了特殊性冲突,在选择器中添加它的一个父元素id,从而提高它的特殊性,如果这能够解决问题,就说明样式表中其他地方很可能有更特殊的规则,它覆盖了你的规则,如果是这种情况需要检查代码,解决特殊性冲突,让代码尽可能简洁
在样式表中使用特殊性
	如果编写CSS的时候,发现不得不多次覆盖一般样式,那么从一般样式中删除需要覆盖的声明,并且将它显式的应用于需要它的每个元素,这样会比较简单
	一般样式非常一般,特殊样式尽量特殊,这样就不需要覆盖特殊样式了.如果发现不得不多次覆盖一般样式,那么从更一般的规则中删除需要覆盖的声明,并且将它显式的应用于需要它的每个元素,这样可能比较简单
在body上使用class或id
	在body上使用class或id,可以根据页面或在站点内覆盖样式,比如希望新的页面具有不同的布局
	使用class标识页面类型,使用id标识特定页面,可以非常灵活的控制站点的设计和布局,编写可维护的代码
继承
	继承和层叠是两回事
	继承表示应用样式的元素的后代会继承样式的某些属性,比如颜色字号,比如body设置文本颜色为黑色,那么body的所有后代文本也都是黑色
	恰当的使用继承可以减少代码中选择器的数量和复杂性,但是如果大量元素继承各种样式,那么判断样式来源就会变得困难
规划,组织和维护样式表
	从HTML页面链接基本样式表,然后将复杂的样式表导入这个样式表 eg:@import url(xxx.css);
	但是导入样式表比链接样式表慢
	在使用多个CSS文件时,还有两个与速度有关的问题
	多个文件会导致从服务器发送更多数据包,数据包的数量会影响下载时间,
	浏览器只能从同一个域名同时下载数量有限的文件(老式浏览器两个,现代浏览器8个)
	所以推荐使用结构良好的单一CSS文件可以提高下载速度
	使用单一CSS文件还能把代码集中在同一个地方,便于维护.
设计代码的结构
	一般性样式
		body样式
		reset样式
		连接,标题,其他元素
	辅助样式
		表单
		通知和错误
		一致的条目
	页面结构
		标题,页脚,导航
		布局
		其他页面结构元素
	页面组件
		各个页面的组件
	覆盖
	end
	规则分隔细致合理,比较容易理解,能够更快的找到寻找的规则
	有意义的注释
	比较复杂的站点可以选择创建一个部署脚本,脚本中删除注释和空白,比如使用CSS优化器,还可以压缩脚本,现代浏览器都可以处理GZIP压缩的文件并进行即使解压,比如使用apache的mod_gzip
	建立文档

第三章 可视化格式模型
	浮动,定位,盒模型
盒模型概述
	页面上的每个元素被看作一个矩形边框,这个框由元素的内容,内边距,边框和外边距组成
	内边距出现在内容区域的周围,元素的背景background应用于内容和内边距
	边框是内边距的区域外边的一条线,可以是实线,虚线,点线
	外边距是透明的,可以用它控制元素之间的间隔
	CSS2.1包含outline属性,绘制在元素框之上,可以用来修复bug,因为不影响页面和布局
	通常各个浏览器对元素内外边距的默认大小解释并不相同,因此使用通配符将margin和padding设置为零是一个好选择 eg:* {margin:0;padding:}
	但是通配符不区分元素,对option等元素有不利影响,因此,使用全局reset将margin和padding设置为零可能更安全
	全局reset的意思是把项目用到的所有标签整合起来,把默认的属性重新设置过
	width和height,增加内边距,边框,外边距不会影响内容区域的尺寸,但是会增加元素框的总尺寸 eg:margin:10px;padding:5px;如果希望这个框达到100px,就需要把内容的宽度设置为70px  #myBox {margin:10px;padding:5px;width:70px}->myBox宽100像素
	内边距,边框,外边距可以应用在一个元素的所有边,也可应用在单独一边.外边距还可以是负值
IE6一下版本使用非标准盒模型
	CSS3的box-sizing属性可以定义使用哪种盒模型,但基本不怎么用
外边距叠加
	两个或更多垂直外边距相遇时,他们将形成一个外边距.这个外边距等于两个发生叠加的外边距的高度中的较大者.
	一个元素包含再另一个元素中时,没有内边距或边框将外边距分隔开,两个元素的顶边距或者底边距也会发生叠加.
	一个元素,没有内容,内边距,边框,顶外边距和底外边距就碰到了一起.也会发生叠加.如果这个外边距碰到另一个元素的外边距,还会发生叠加
	这就是一系列空的p元素占用空间非常小的原因,他们的所有外边距都叠加到一起,形成一个小的外边距
	只有普通文档流中块框的垂直外边距才会发生外边距叠加,行内框,浮动框,绝对定位框之间的外边距不会叠加
定位概述
	理解可视化格式模型和定位模型之间的细微差异
可视化格式模型
	块框:p,h1,div等元素被称为块级元素啊,这些元素显示一块内容
	行内框:strong,span等元素被称为行内元素,这些元素显示一行内容
	可以使用display改变框的类型,display=block可以把行内框设置为块框,display=none可以把元素设置为没有框,就不显示,display=inline-block可以让元素像行内框一样水平显示
	CSS中有3种基本的定位机制:普通流,浮动,绝对定位
	默认所有框都在普通流中定位
	普通流中元素框的位置由元素在HTML中的位置决定
	块框从上到下一个接一个垂直排列,框间的垂直距离由框的垂直外边距计算出来
	行内框在一行中水平排列,可以用水平内边距,边框,和水平外边距调整元素间的水平间距
	垂直内边距,边框,和垂直外边距并不影响行框的高度
	行内框上设置显示的高,宽是没有影响的
	默认的,行框的高度总是能够容纳它包含的所有行内框
	修改行框的高度的方法是行高
	display=inline-block声明后的框仍然有块级框的行为,比如显示的设置宽度高度垂直外边距和内边距
	火狐3.0,IE8等以下版本不支持
	匿名块框:将文本添加到块级元素的开头时候,这些文本会作为块级元素处理 eg:<div>aaaa<p>bbb</p></div> aaaa作为块级元素处理
	块级元素内的文本行也会发生类似的情况,一个包含3行文本的段落,每行文本形成一个匿名行框,无法直接对匿名块或者行框应用样式,除非使用不常用的:first-line伪元素
相对定位和绝对定位
	相对定位,根据本元素的起点通过设置垂直或水平距离,确定元素的位置
	相对定位,实际上被看作普通文档流定位模型的一部分,无论元素在不在本来的位置,是否移动,元素依然占据本来的空间,元素可以覆盖其他框
	绝对定位,根据本元素的距离最近的祖先元素的起点通过设置垂直或水平距离,确定元素位置,如果没有已定位的祖先元素,则找初始包含块,可能是画布或者HTML元素
	绝对定位,与文档流无关,不占据空间,元素可以覆盖其他框
	相对定位是相对于元素在文档流中本来的位置,绝对定位是相对于距离元素最近的已定位的祖先元素
	可以通过设置z-index属性来控制绝对定位的叠放次序,z-index值越高,元素框在栈的位置中越高
	eg:一个文本锻炼对准大框的右下角chapter03 test
	尺寸改变会导致绝对定位的框重叠,破坏布局,因为绝对定位改变,不影响普通文档流
固定定位
	固定定位是绝对定位的一种,固定元素的包含快是视口(viewport),可以在窗口中相同的位置创建浮动元素
浮动
	浮动模型可以左右移动,直到它的外边缘碰到包含框(包含这个元素的框),或者碰到另一个浮动框的边缘
	浮动框,与文档流无关,不占据空间,元素可以覆盖其他框
	如果包含块太窄,无法容纳水平排列的浮动元素,那么其他浮动块向下移动,直到有足够空间的地方.如果浮动元素的高度不同,那么当他们向下移动时可能会被其他浮动元素卡住
行框和清理
	浮动元素旁边的行框被缩短,从而给浮动元素留出空间,因此行框围绕浮动框.
	创建浮动框可以使文本围绕图像.
	阻止行框围绕在浮动框的外边(行框围绕浮动框),需要对包含这些行框的元素应用clear属性.
	clear属性有left,right,both,none,表示那边不应该挨着浮动框
	clear时,浏览器在元素顶上添加足够的外边距,使元素的顶边框垂直下降到浮动框外面
	浮动元素脱离了文档流,不影响周围的元素,但是,对元素的清理实际上是为前面的浮动元素留出了垂直空间,这样解决了绝对定位垂直高度改变不影响周围元素,破坏设计的问题
	eg:chapter03-test1.html 因为容器元素不占据空间,所以容器元素不包围他们,添加一个用于清理的元素,可以迫使容器元素包围浮动元素,这样可以实现希望的效果,但是会添加不必要的代码.如果没有现成的元素可以应用clear,还可以选择浮动容器div eg:chapter03-test2.html 但是下一个元素会收到这个浮动元素的影响,所以需要权衡选择添加少量的额外标记还是浮动容器.
	overflow属性定义 在包含的内容大小超过指定大小的容器时元素应该怎么样.,默认情况下内容会溢出到框外,进入相邻的空间.
	应用值为hidden,auto的overflow属性有一个有用的副作用,自动的clear包含的任何浮动元素,这个清理方法的问题是并不适合所有的情况,可能会产生滚动条或截断内容
	使用CSS生成的内容或JavaScript对浮动元素进行清理,两者的基本概念是相同的:动态的想标记中添加进行清理的元素:eg:chapter03-test3.html 结合使用:after伪类和内容声明在指定的现有内容的末尾添加新的内容,添加了一个".",不希望新内容占据垂直空间height=0,不希望新内容在页面展示所以visibility=hidden,被清理的元素在他们的顶外边距上添加了空间,所以生成的内容需要display=block.这个方法在IE6以下无效,但是目前不考虑兼容IE6以下版本浏览器了

第四章 背景图像效果
	纯修饰性的图片可以作为CSS背景图
背景图像基础
	background-image:url(/img/pattern.gif); 使用背景图
	background-repeat:repeat-x; 水平平铺
	background-color:#ccc; 添加背景色
	背景图包含内容
	